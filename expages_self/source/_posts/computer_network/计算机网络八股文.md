---
thumbnail: 
title: 计算机网络八股文
date: {{ date }}
tags: [计算机网络,interview]
categories: 
 [计算机网络]
toc: true
top: 2
recommend: 2
keywords: [计算机网络,面试题]
mathJax: false
comments: true
---

# 1. 计算机网络八股文

## 1.简述OSI七层协议

OSI七层协议包括：应用层、表述层、会话层、传输层、网络层、数据链路层、物理层

## 2.简述TCP/IP五层协议

TCP/IP五层协议包括：应用层、传输层、网络层、数据链路层、物理层

<!-- more -->

## 3.物理层有什么用

主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现位电流电压上的强弱。网卡、集线器工作在这一层

## 4.数据链路层有什么用

在不可靠的物理介质上提供可靠的传输，==接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层==。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。==提供物理地址寻址功能==。交换机工作在这一层。

## 5.网络层有什么用

将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由器到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。

## 6.传输层有什么用

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## 7.会话层有什么用

建立会话：身份验证，权限鉴定等；保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输数据；断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。

## 8.表示层有什么用

对数据格式进行编译，对收到或发出的数据根据应用层的的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。

## 9.应用层有什么用

提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。

## 10. TCP和UDP的区别

TCP作为面向流的协议，提供可靠的、面向连接的传输服务。UDP作为面向报文的协议，不提供可靠交付，并不需要连接，提供点对点通信，支持多播和广播。

## 11. TCP为何可靠

TCP有三次握手建立连接，四次挥手关闭连接的机制。除此之外还有滑动窗口和拥塞控制算法，还保留超时重传机制，对于每份报文也存在校检，保证报文可靠性

## 12. UDP为何不可靠

UDP面向数据报、无连接的，数据包发出去，就不保留数据备份了。仅在IP头数据包头部加入校检和复用。UDP没有服务端和客户端概念（只有发送和接收）。UDP报文过长的话是交给IP切成小段，如果某段报文报废就废了，不提供重传机制。

## 13. 简述TCP粘包现象

**MTU **：最大传输单元由，**网络接口层（数据链路层）**提供给**网络层**最大一次传输数据的大小；一般 MTU=**1500 Byte**。假设IP层有 <= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有> 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。

**MSS** ：TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和  TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。

![](https://cdn.jsdelivr.net/gh/lx807/blog_image@master/image/image-20220317101022658.png)

TCP是面向流协议，发送的单位是字节流，因此会将多个小尺度数据疯涨在一个tcp报文中发出去，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。

### 1. 为什么要组装发送的数据

 TCP **切割**数据包是为了能顺利通过网络这根水管。相反，还有一个**组装**的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较**浪费**网络 io 。

### 2. 怎么处理粘包

+ 加入特殊标志

![](https://cdn.jsdelivr.net/gh/lx807/blog_image@master/image/image-20220317100642444.png)

+ 加入消息长度信息

![](https://cdn.jsdelivr.net/gh/lx807/blog_image@master/image/image-20220317100710284.png)

这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。

## 14. 简述TCP协议的滑动窗口

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，防止方法放因发送速度过快而导致自己被淹没。

## 15. 简述TCP协议的拥塞控制

**对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏**，这种情况就叫做**网络拥塞**。

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢启动门限ssthresh状态变量。

慢启动：当cwnd<ssthresh时，使用慢启动算法。在慢启动算法中，把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认，cwnd指数增长。当cwnd=ssthresh时，改用拥塞控制算法

拥塞控制算法：每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

快速重传(Fast retransmit)
要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
　　快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

快速恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并且把cwnd设置为1，重新进行慢启动。

快速恢复：当发送方连续收到三个重复确认，，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为改变后的ssthresh值，之后执行拥塞控制算法（“加法增大”）。

![](https://cdn.jsdelivr.net/gh/lx807/blog_image@master/image/1090617-20190114175347307-1712551505.jpg)

## 16. TCP三次握手过程

1. 第一次握手：客户端将标志位SYN置为1，随机产生一个序列值seq=x，并将该数据包发给服务端，客户端进入syn_sen状态，等待服务端确认。
2. 第二次握手：服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发给客户端以确认连接请求，服务端进入syn_ rcvd状态。
3. 第三次握手：客户端收到确认后检查，如果正确则将标志位ACK为1，ack=y+1，并将该数据包发给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了。

## 17. 为什么TCP握手需要三次，两次行不行？

不行。TCP进行可靠传输的关键在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值。

如果只是两次握手，至多只有客户端的起始值的其实序列能被确认，服务端的序列号则得不到确认。

## 18. 简述半连接队列

TCP握手中，当服务器处于SYN_ RCVD状态，服务器会把此种状态下的请求连接放在一个队列中，这个队列被称为半连接队列。

## 19. 简述SYN攻击

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

优化方法：

+ 缩短SYN Timeout时间
+ 记录IP，若连续收到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃

## 20. TCP四次挥手过程

第一次挥手：客户端发送一个FIN=1，以及一个序列号seq=u，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。

第二次挥手：服务端收到FIN后，发送一个ACK=1确认标志和客户端的确认序列号ack =u+1，子集的序列号seq=v，进入CLOSE_WAIT状态，同时继续发送未发送完的数据。

第三次挥手：客户端收到服务器确认后，进入FIN_WAIT_2状态，等待服务器发出的连接释放报文段；服务器发送完数据后，发送释放FIN=1信号，确认标志ACK=1，确认序列号ack=u+1,自己的序列号seq=w，服务器进入LAST_ACK(最后确认态)

第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自身的seq=u+1，客户端进入TIME_WAIT(时间等待，两个最大报文段寿命，MSL)。客户端经过2MSL后，自动CLOSE；服务端收到确认后，立刻进入CLOSE状态

![](https://cdn.jsdelivr.net/gh/lx807/blog_image@master/image/73849c15be2fd0bac7d14171b45baa17.png)

## 21. 为什么TCP挥手需要4次

主要原因时当服务端收到客户端的FIN数据包后，服务端可能还有数据没有发完，不会立刻CLOSE。

所以服务端会先将ACK发过去告诉客户端我收到了你的断开请求，但还需要一点时间来发送剩下的报文段，发完之后在将FIN包发给客户端表示现在可以断开连接了、之后客户端需要收到FIN包后发送ACK确认断开信息给服务端。

## 22. 为什么四次挥手释放连接时需要等待2MSL

客户端需要保证最后一次发送的ACK报文到服务器，如果服务器未收到，可以请求客户

端重发，这样客户端还有时间再发，重启2MSL计时。

## 23. 简述DNS协议

DNS协议时基于UDP的应用层协议，它的功能使根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。

## 24. 简述DNS解析过程

1. 客户机发出查询请求，浏览器先检查自身缓存中有没有解析过，如果有，解析结束。
2. 如果浏览器没有在缓存中没有找到（专业点叫还没命中），浏览器会检查本地计算机缓存，如果有，结束解析；若没有找到，
3. 如果还没命中，就会将请求发送给本地DNS服务器(LDNS，一般是运营商，如联通，电信)。
4. 如果LDNS仍然没有命中，就会将此请求发送到根域名DNS服务器。
5. 根域名服务器返回给LDNS一个所查询的主域名服务器(gTLD Server，国际顶尖域名服务器，如`.com` `.cn` `.org`等)地址。
6. LDNS再次发送请求给上一步返回的gTLD
7. 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
8. Name Server根据映射关系表找到目标IP，返回给LDNS
9. LDNS缓存这个域名和对应的IP
10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析结束。

![](https://cdn.jsdelivr.net/gh/lx807/blog_image@master/image/Center.png)

## 25. 简述HTTP协议

http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身是一种无状态的协议。

## 26. 简述cookie

http协议本身是无状态的，为了使其能处理更加复杂的逻辑，http/1.1引入了cookie来保存状态信息。cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端的身份，以此可以做个性化推送，免账号登录等等

## 27. 简述session

session用于标记特定客户端信息，存在服务器里的一个文件里。一般客户端带cookie对服务器进行访问，可通过cookie中的session id从整个session中查到服务器记录的关于客户端的信息。

## 28. 简述http状态码和对应的信息 

 1XX：接收的信息正在处理 

 2XX：请求正常处理完毕 

 3XX：重定向 

 4XX：客户端错误 

 5XX：服务端错误 

 常见错误码： 301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到

## 29. 简述http1.0

规定了请求头和请求尾，响应头和响应尾(get post)

每一个请求都是一个单独的连接，做不到连接的复用

## 30. 简述http1.1的改进

http1.1默认开启长连接，再一个TCP连接上可以传送多个http请求和响应。使用tcp长连接的方式改善了http/1.0短连接造成的性能开销

支持管道（pipeline）网络传输，只要第一个请求发送出去了，不必等其回来，就可以发送给第二个请求出去，可以减少整体的响应时间。

服务端无法主动push

## 31. 简述http短连接和长连接的区别

http中的长连接和短连接指http底层TCP的连接

短连接：客户端与服务端进行一次http连接操作，就进行以此tcp连接，连接结束tcp关闭连接。

长连接：如果http头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的tcp连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。

## 32. 简述http2.0的改进

提出多路复用。多路复用前，文件是串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。（在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。）

## 33. http与https的区别

http所有传输的内容都是明文，并且客户端和服务端都无法验证对方的身份。https具有安全性的ssl加密传输协议，加密采用堆成加密，https协议需要到ca申请证书

## 34. 简述TLS/SSL,http，https的关系

ssl全称为Secure Sockets Layer，即安全套接层，其升级版TLS Transpost Layer Security，传输层安全协议，均用于再传输层为数据通讯提供安全支持。

可以将https协议简单理解为http协议+TLS/SSL

## 35. http的连接过程

- 客户端将支持的加密方式发给服务端。
- 服务端并选择一套客户端支持的加密方式，以CA证书的形式返回给客户端，证书中还包括公钥，颁证机构，网址，有效时间等
- 客户端通过CA机构的公钥对证书进行验证，验证通过后，客户端产生对称密钥，通过服务端证书的公钥去加密这个密钥并发送给服务端
- 服务端收到后并使用私钥解密，获取了对称密钥，接下来的通信就可以通过该密钥来加密、解密

### 1. CA证书是否安全

网站在使用https前，需要向CA机构申领一份数字证书，数字证书里包含证书持有者细腻些、公钥信息等。CA机构生成一对非对称密钥（唯一性），CA机构对证书明文进行HASH，将hash后的值通过私钥加密，得到数字签名，==明文和数字签名共同组成了数字证书==。

由于只有CA机构才有私钥，所以无法对经过加密后的数字签名进行篡改，数字签名时进行hash的目的是因为证书信息一般很长，经过hash后可以得到固定的长度，加解密变得很快。

浏览器验证证书有效性：浏览器收到网站的证书后，通过CA机构获取对应的公钥，通过公钥进行解密，然后通过对明文进行hash对比，看证书是否被篡改。

### 2. **每次进行HTTPS请求时都**必须在SSL/TLS层进行握手传输密钥吗？

浏览器客户端访问同一个https服务器，可以不必每次都进行完整的TLS Handshake，因为完整的TLS Handshake，涉及到**认证服务器的身份**（数字证书），需要做大量的非对称加密/解密运算，此外还需要做**伪随机函数PRF**，通过“**Pre-Master Key”、“Server Nonce”、“Client Nonce**”共同推导出**session key**，**非对称加密算法RSA/DSA非常耗费CPU资源。**

为了克服这个困难，服务器维护一个以**session ID**为索引的结构体，用于临时存放session key，并在**TLS handshake 阶段分享给浏览器**。

当浏览器重新连接https 服务器时，TLS handshake 阶段，出示自己的session ID，**服务器获得session ID，以此为索引，可以获得和该浏览器共同拥有的session key，使用session key可以直接对用户流量做加密/解密动作。**

这样避免了大量的幂、指数计算。

当然，如果服务器没有查找到session ID，双方的TLS安全参数协商按照正常流程走。

## 36. Get与Post的区别

Get：指定资源请求数据，刷新无害，get请求的数据会附加到URL中，传输数据的大小受url的限制。

post：向指定资源提交要被处理的数据。刷新会使数据重复提交。post在发送数据前会先将请求头发送给服务端进行确认，然后才真正发送数据。

## 37. get方法参数有大小限制吗

一般http协议里并不限制参数大小。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度线之，因此使get请i去在浏览器实现层面上看会有长度限制。

## 38. REST API

REST API全称为表述性状态转移（Representational State Transfer，REST），即利用HTTP中get、post、put、delete以及其他的http方法构成rest中数据资源的增删改查操作：

+ Create： POST
+ Read： GET
+ Update： PUT/PATCH
+ Delete： DELETE

## 39. 浏览器中输入一个网址后，具体发生了什么

1. 进行DNS解析操作，根据DNS解析结果查到服务器IP地址
2. 通过IP寻址和arp(地址解析协议)，找到服务器，并利用三次握手建立TCP连接
3. 浏览器生成HTTP报文，发送http请求，等待服务器响应
4. 服务器处理请求，并返回给浏览器
5. 根据http是否开启长连接，进行tcp的挥手过程
6. 浏览器根据收到的静态资源进行页面渲染

# 2.参考来源

1. [整个八股文主要来源](https://www.nowcoder.com/discuss/639658?channel=-1&source_id=profile_follow_post_nctrack)
2. [https主要来源](https://zhuanlan.zhihu.com/p/43789231)
3. [DNS解析主要来源](https://blog.csdn.net/m0_37812513/article/details/78775629?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164880608516781685315488%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164880608516781685315488&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-78775629.142^v5^pc_search_quality_down&utm_term=%E7%AE%80%E8%BF%B0dns%E8%BF%9B%E8%A1%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B&spm=1018.2226.3001.4187)
4. [TCP粘包主要来源](https://mp.weixin.qq.com/s/C8VDSeCH2x-9i1Zt67Eq_w)





























































